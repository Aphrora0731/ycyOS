This file is used to record anything happened during development.
Such as bugs, idea and notes.

ABOUT NAME:
	*All struct prototype should be named as "StructPrototype"
	*All function and variable should be named as "fuction_name" or "variable_name"


ABOUT MBR:
	*When writing MBR file,the beginning of nasm code should be 07c0,because in the very first computer, the least required memory size is 32KB, the beginning is used by BIOS. 
	Therefore, to remain as more as possible continuous memory space to OS, mbr file is put at the end of 32KB memory space.

	*at the end of MBR file should be 55aa and I don't know why.
	
	*It turns out that you should implemented a proc call in nasm code and I don't know why.

	*BIOS magically saved 512 byte for MBR(boot) as data segemnt.It turns out in ycyOS.img, the binary code of loader.s is just behind signiture 0xaa55, but when the ycyOS.img is loaded by BIOS, loader.s begins at 0x8000.


ABOUT LONG JUMP BETWEEN BOOTSECTOR AND KERNAL:
	*You should be very careful about segment and real address in memory.
	*When you excute instruction as jump CS:IP, you should really know where to jump.
	*I don't know why 2nd print in bootsector failed

ABOUT GDT&IDT&SEGMENT SELECTOR
	*GDT(global descriptor table)is a table of information about segements,including size,start position and type.You have to load tell computer where to find it in memory by lgdt assembly instruction
	*The first descriptor in GDT is not used.
	*Index in selector means which position this descriptor is in table.
	*The base in descriptor is phisical address without 4 bits shiftted like real mode did in segment register

ABOUT VIDEO MEMORY
	*0xb800 is segment address.The REAL start is 0xb8000.SHIT!

ABOUT MIXING ASSEMBLY AND C
	*To passing argument,you should choose a calling convention before and obey it,in our case,cdecl.
	*print-stack command is useful while debug in bochs.
	*I specified stack segment before, not sure if it's necessary,but I believe an OS programmer should always take over his memory space.

ABOUT interrupt
	*remember sending EOI to 8259A.For now it's the best way to reset keyboard buffer
	*File interrupt.h declare interrupt function.
	 When user calling an intehandler(keyboard intterrupt,for example),kb_int() should enbble keyboard int by programming 8259a.
	 Then waiting assembly function for keyboard,get a scancode,transform it into ascii and put it into keyboard buffer
	

ABOUT KEYBOARD INTERRUPT
	*C keyboard-int handler provokes an int and manage keyboard input buffer
	*A process won't need keyboard input before itslef.So keyboard int should only be enabled when we really need it.

A BUG ABOUT CALL AND STACK DURING:
	*interrupt handler int21h calls kb_int and passing parameter by stack (push)
	*however, after kb_int returns, it did not clean the stack
	*another wierd thing.If you push ax in 32-bit (push a word on double word wide stack),it won't clean the exited stack top, or become the new top with zero filled high bits as I expected
	*it shift the current stack top,and take the origin lower word place
	*in this case, stack was
	top
	0x00000028
	...
	bottom
After push ax (ax restores 0xfa)
	top
	0x002800fa
	...
	bottom
	*That's the most wierd thing I've ever met
	*The solution to that bug is, always push a big enough register.On 32-bit,you should push eax.That will do.

A PROBLEM ABOUT OFFSET WITH RESPECT TO SS OR DS:
	*When using stack to pass pointer parameters, the compiler passes the offset with respect to SS
	*However,when program actually using this parameter, it consider the offset as with respect to DS
	*My solution is un-natural but simple.With consideration that ds base is 0x0000 and ss base is 0x7000.I just add the difference in assembly code.
	*It's wierd and may have a repurcussion when passing and using happens just in Compiler-generated C code.
	*The instance could be found in the implementation of assembly function print

ABOUT LINGKNG:
	*Well, I don't know how that worked.BUt array char printable_ch[] has two instance. If I delete one interrupt.o, then undefined reference occurred. SHIT

ABOUT KEYBOARD SCAN CODE:
	*I am so so confused why the key 'Z' and 'Y' exchanged their scan code.
	*But I fixed it by simply change them in printable_ch[] anyway.

ABOUT ASSEMBLY FUNCTION PRINT:
	*I implement a basice print format control in that function by passing third parameter which represents the position in vedio memory of charactor to print.
	*Should add another paramter in function Cprint to designate the start point by (x,y),and figure out present argument pos by f(x,).
	*function above is implemented.80 charactor per line.Therefore the pos=col + 80*row
	*pos is argument of assembly print,col and row is argument of Cprint
